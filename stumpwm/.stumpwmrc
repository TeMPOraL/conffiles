;;; -*-lisp-*-
;;; Yay, my fist StumpWM config xD.

(in-package :stumpwm)
(ql:quickload :external-program)

(defun run-external-program (cmd args)
  (with-open-stream (s (make-string-output-stream))
    (external-program:run cmd args :output s)
    (string-trim '(#\Newline #\Space) (get-output-stream-string s))))

(defun current-hostname ()
  (run-external-program "hostname" '()))

(defun current-ips ()
  (run-external-program "hostname" '("-I")))

(defun current-dropbox ()
  ;; TODO colors
  (run-external-program "dropbox" '("status")))

;;; mode line
(setf *mode-line-timeout* 1)

(setf *screen-mode-line-format*
      (list "%g|%v"
            "^>"
            '(:eval (current-dropbox))
            " ^1"
            (current-hostname)
            "^n | "
            (current-ips)
            " | "
            "^B%d^b"))

(setf *time-modeline-string*
      "^b%a %b ^B%e^2 %H:%M:%S^n")

(defun cat (&rest strings) "Concatenates strings, like the Unix command 'cat'. A shortcut for (concatenate 'string foo bar)."
       (apply 'concatenate 'string strings))

;;; modeline
;; Turn on the modeline
(if (not (head-mode-line (current-head)))
    (toggle-mode-line (current-screen) (current-head)))

;;; GROUPS
(defun group-exists-p (group-name)
  (find-if (lambda (group)
             (string= group-name
                      (group-name group)))
           (screen-groups (current-screen))))

(defun ensure-group (group-name)
  (unless (group-exists-p group-name)
    (stumpwm::run-commands (cat "gnewbg " group-name))))

(setf (group-name (first (screen-groups (current-screen)))) "Terminals") ;FIXME need to sort by group # first.

(ensure-group "Emacs")
(ensure-group "Browser")
(ensure-group "SQL")
(ensure-group "IRC")

;; bind g-e to switch to Emacs group.
;; bind g-b to switch to browser group.
;; bind g-t to switch to terminal group.

(defcommand emacs () ()  ;! redefining emacs command
  "Start Emacs or switch to it, if it is already running."
  (run-or-raise "emacs" '(:class "Emacs")))

;;; TODO make some direct connection to Alice xD.

(defcommand color-map () ()
            "Show current color map."
            (echo-string (current-screen) "^0 0^1 1^2 2^3 3^4 4^5 5^6 6^7 7"))

;;; Hooks
(defun ensure-hook (hook fn)
  (remove-hook hook fn)
  (add-hook hook fn))

(defun my-modeline-click-hook (screen button x y)
  (message "Clicked: X:~A, Y:~A" x y))

;; FIXME
;; (ensure-hook *mode-line-click-hook* 'my-modeline-click-hook)

;;; Fix up the keyboard
(run-external-program "setxkbmap" '("-layout" "pl" "-option" "ctrl:nocaps")) ;XXX y u no work?
;;; TODO start dropbox -- dropbox start
;;; TODO start pulseaudio -- if(pulseaudio --check == 0) { pulseaudio -D }

;;; TODO steal some stuff from https://github.com/joelagnel/stumpwm-goodies

;;; TODO volume display
;;; pactl list sinks | grep -e "^[[:space:]]Volume" | awk '{print $5 ; print $12}'


;;; Volume control
;;; TODO better volume control
;;; Will work like this:
;;; - var for volume level, mutedp
;;; - each operation (+/-/mute) also updates the volume level (and mute status, if we'll use pulseaudio to handle that state) and refreshes modeline
;;; - cached volume level is displayed in modeline
;;; - if there isn't a convenient mute in pulseaudio, implement it internally - via flipping mutedp and setting volume to 0 or setting it to cached value, depending on mutedp value
;;; - extension: handle C-[volume] as 1%
;;; - extension: implement limit at 100%, use S-[volume] and C-S-[volume] to go over 100%
;;;   - this will most likely require to set volume to absolute value (based on what's stored), instead of using relative
;;;   - should not be a problem if we fetch the real _before_ executing the increase/decrease

(define-key stumpwm:*top-map* (stumpwm:kbd "XF86AudioLowerVolume") "exec pactl set-sink-volume 0 -5%")
(define-key stumpwm:*top-map* (stumpwm:kbd "XF86AudioRaiseVolume") "exec pactl set-sink-volume 0 +5%")
(define-key stumpwm:*top-map* (stumpwm:kbd "XF86AudioMute") "exec pactl set-sink-volume 0 0%")
